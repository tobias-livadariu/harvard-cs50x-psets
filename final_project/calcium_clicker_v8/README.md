# CALCIUM CLICKER
#### Video Demo: https://youtu.be/llJj8coU7xg
#### Description:
Calcium Clicker is an incremental web application inspired by other famous incremental web apps like "Cookie Clicker," "Swarm Simulator," and "Antimatter Dimensions." In Calcium Clicker, users play as a necromancer to build their army of undead skeletons as large as possible. Users can get skeletons in two ways. The user can click the "Dig Up More" button to dig up skeletons manually, or they can purchase autodiggers to dig up skeletons for them automatically. Each autodigger digs up one skeleton per second, with multiple autodiggers stacking to produce very fast gains once the user buys a large number of them. The user can increase the number of skeletons they get per click by upgrading their shovel to higher tiers, with higher tiers generating exponentially more skeletons per click and costing exponentially more skeletons to buy. The web app displays two major text boxes at the top of the DOM to the user. The first has an id of "skeleton-count," which shows the skeletons the user currently owns and can spend on upgrades. The second has an id of "total-skeletons," which displays the total skeleton count that the user has generated, spent or not, over their account's entire lifetime. It is very important to note that certain functionalities of this program were taken from week 9's Finance pset. The login and logout routes, the @login_required route decorator, and parts of the configuration done to app.py to ensure it can handle user account data were taken from Finance's distribution code. Additionally, the register route was taken from my work in Finance, and the structure of Calcium Clicker's sqlite3 database was inspired by the database structure in Finance. It is also important to note that ChatGPT helped teach me how to use certain tools and syntax that I needed to complete this project. For example, it taught me how to use AJAX to asynchronously update data in the page's DOM without constantly reloading the page. It also taught me how to use fetch() and .then() in JavaScript to extract data from my flask routes and create anonymous functions that use the extracted data to do work. ChatGPT also helped me optimize my flask routes to be maximally efficient and to contain as few sqlite3 queries as possible. However, it is important to note that I did not copy any code from ChatGPT in this assignment. Rather, I used its suggestions to improve and build on my own ideas.

The user gains the ability to buy autodiggers and to upgrade their shovel when their total skeleton count reaches 10. Reaching a total skeleton count of 10 will trigger the page to refresh through the refreshPage() JavaScript function, generating more elements on the screen. When buying autodiggers, the user can choose between buying one, buying ten, or buying the maximum amount they can currently afford. The ability to buy multiple autodiggers at once was implemented through JavaScript and two flask routes, one that gets the number of autodiggers the user can afford and another that purchases the autodiggers. If the user buys a single autodigger, only the route that purchases autodiggers will run. After fetching the user's current skeleton count and the next autodigger's cost from the web app's SQL database, this route will make the transaction, and the database values will be updated. If the user decides to buy multiple autodiggers, first, the route that determines how many autodiggers the user can afford is run, which then passes values to the route that buys autodiggers, causing it to run slightly differently and buy multiple autodiggers depending on the values that the first route passed to it. The DOM is updated through asynchronous JavaScript to display the next autodigger count in either scenario. When upgrading their shovel, the user clicks a button on the screen that calls the buyShovel() JavaScript function. This function will fetch the "/buyShovel" route, which will SELECT values from the SQL database, check if the user can afford a shovel upgrade, and complete the transaction if the user has enough skeletons. It will then return, as JSON, the user's updated current shovel level and the maximum shovel level, a list of all shovel names based on their level, the cost of buying the next shovel, and the current skeleton count. The buyShovel() function will then fetch the "/updateStats" route, which will update the row in the SQL database's stats table containing the user's specific user_id with the new skeletonsPerClick value. This value is then returned to the buyShovel() function as JSON through fetch, which uses it, in conjunction with the values returned by the "/buyShovel" route, to asynchronously update the DOM with the user's new shovel and skeletonsPerClick.

Since Calicum Clicker is an incremental game, numbers on the DOM quickly grow. This fast growth could become problematic as text gets longer and longer, eventually reaching the boundaries of its container and wrapping, which would ruin the style of the web app. To counteract this, I have implemented a jinja2 filter and a JavaScript function called formatNumberSuffix. This function takes in an integer as input and finds the biggest triple power of ten (e.g., one thousand, one million, etc.), which is less than the integer input. It will then divide that integer by the power of ten,Â round the result to 2 decimal places, and add a unique suffix depending on the integer's size. For example, if 1023 were run through formatNumberSuffix(), it would output 1.02k. This number formatting method greatly improves the web app's readability and aesthetic, but it was tricky to implement. At first, some of Calcium Clicker's JavaScript functions read numeric values for skeleton count directly from the DOM. Doing this was problematic because if the text on the DOM was concatenated and given non-numeric characters, precise values could no longer be extracted from it. To fix this issue, the globalVariables.js file was made, and the userSkeletons dictionary was defined within it. This dictionary held the totalSkeletons and skeletonCount values, allowing JavaScript functions to access and modify the user's skeleton count variables without constantly fetching SQL routes, which would slow down the program and without accessing text on the DOM. The use of this dictionary allowed for another advantage. Before implementing userSkeletons, many JavaScript functions were asynchronously modifying the totalSkeletons and skeletonCount textboxes simultaneously. Due to this, functions would sometimes overwrite each other's work, and it also pointlessly increased the complication of the web app. To resolve this, I moved all updates of the tags whose ids were total-skeletons and skeleton-count to the resyncDOM.js function. This function fetches the values in totalSkeletons every 25 milliseconds, runs them through the formatNumberSuffix() function, and assigns the output to the text content of the total-skeletons and skeleton-count tags on the DOM. I chose to do this refresh every 25 milliseconds because another script, called perSecondOperations.js, modifies the values in totalSkeletons every 25 milliseconds. The file perSecondOperations.js contains a function that adds the number of skeletons the user's autodiggers have dug up in the last 25 milliseconds to the user's total skeletons and skeleton count. In reality, the gains generated by the autodiggers are only saved to the user's skeletonCount and totalSkeletons columns in the database every second to minimize the number of sqlite3 prompts. Still, this smooth accumulation of skeletons on the screen makes the web app look more responsive, and that is why the DOM is resynced every 25 milliseconds.

I hope this README clarified the purpose and functionality of Calcium Clicker! Please look through my code if you need further clarification about any part of my final project. It is full of comments that explain the logic behind every flask route and JavaScript function. Thank you for your time!
