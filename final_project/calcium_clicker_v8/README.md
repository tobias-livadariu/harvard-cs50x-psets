# CALCIUM CLICKER
#### Video Demo:  <URL HERE> ::TODO
#### Description:
This is an incremental web application inspired by other famous incremental web apps like "Cookie Clicker", "Swarm Simultor", and "Antimatter Dimensions". In Calcium Clicker, you play as a necromancer with the objective of building your army of undead skeletons as large, and strong, as possible. This is done in two ways. The user can either click the "Dig Up More" button to manually dig up skeletons every click, or they can purchase autodiggers to automatically dig up skeletons for them. Each autodigger digs up one skeleton per second, with multiple autodiggers stacking to produce very fast gains once the user buys a large number of them. The number of skeletons the user gets per click can be increased by upgrading their shovel to higher tiers, with higher tiers of shovel generating exponentially more skeletons per click, but also costing exponentially more skeletons to buy. The web app displays two major text boxes at the top of the DOM to the user. The first has an id of "skeleton-count" and it displays the skeletons that the user currently owns and can spend on upgrades. The second has an id of "total-skeletons" and it displays the total skeleton count that the user has generated, spent or not, over their account's entire lifetime. It is very important to note that certain functionalities of this program were taken from week 9's Finance pset. The login and logout routes, as well as the @login_required route decorator, and parts of the configuration done to app.py to ensure that it is properly able to handle user account data were taken from Finance's distribution code. Additionally, the register route was taken from my work in Finance, and the structure of Calcium Clicker's sqlite3 database was inspired by the database structure in Finance. It is also important to note that ChatGPT helped teach me how to use certain tools and syntax that I needed to complete this project. For example, it taught me how to use AJAX to asyncronously update data in the page's DOM without constantly reloading the page. It also taught me how to use fetch() and .then() in JavaScript to extract data from my flask routes and create anonymous functions that use the extracted data to do work. ChatGPT also helped me optimize my flask routes to be as efficient as possible, and to contain as few sqlite3 queries as possible. It is important to note, however, that I did not copy any code from ChatGPT in this assignment, rather, I used its suggestions to improve and build on my own ideas.

The user gains the ability to buy autodiggers and to upgrade their shovel when their total skeleton count reaches 10. This will trigger the page to refresh through the refreshPage() JavaScript function, and generate more elements on the screen. When buying autodiggers, the user has a choice between buying one, buying ten, or buying the maximum amount that they can currently afford. This was implemented through JavaScript and two flask routes, one that gets the number of autodiggers the user is currently able to afford, and another that purchases the autodiggers. If the user decides to only buy one autodigger, only the route that purchases autodiggers will run, and after fetching the user's current skeleton count and cost of next autodigger from the web app's SQL database, it will make the transaction and update the database values. If the user decides to buy multiple autodiggers, first the route that determines how many autodiggers the user can afford is run, which then passes values to the route that buys autodiggers, causing it to run slightly differently and buy multiple autodiggers depending on the values that the first route passed to it. In either scenario, the DOM is then updated through asyncronous JavaScript to display the next autodigger count. When upgrading their shovel, the user clicks a button on the scren that calls the buyShovel() JavaScript function. This function will fetch the "/buyShovel" route, which will SELECT values from the SQL database, check if the user is able to afford a shovel upgrade, complete the transaction if the user has enough skeletons, and return the user's updated current shovel level, as well as the maximum shovel level, a list of all shovel names based on their level, the cost of buying the next shovel, and the current skeleton count. The buyShovel() function will then fetch the "/updateStats" route which will update the row in the SQL database's stats table containing the user's specific user_id with the new skeletonsPerClick value. This value is then returned to the buyShovel() function through fetch as json, which uses it, in conjunction with the values returned by the "/buyShovel" route, to asyncronously update the DOM with the user's new shovel and skeletonsPerClick.

Since Calicum Clicker is an incremental game, numbers on the DOM quickly grow. This could become problematic as text gets longer and longer, eventually reaching the boundries of its container and wrapping, which would ruin the style of the web app. To counteract this, I have implemented a jinja2 filter and a JavaScript function, both called formatNumberSuffix. This function takes in a integer as input, and finds the biggest triple power of ten (eg, one thousand, one million, etc.) which is less than the integer input. It will then divide that integer by the power of ten,  round the result to 2 decimal places, and add a special suffix depending on the integer's size. For example, if the number 1023 was run through formatNumberSuffix(), it would output 1.02k. This greatly improves the readability and aesthetic of the web app, but it was tricky to implement. At first, some of Calcium Clicker's JavaScript functions extracted numeric values for skeleton count directly from the DOM. This was problematic because if the text on the DOM was concatonated and given non-numeric characters, precise values could no longer be extracted from it. To fix this issue, the globalVariables.js file was made, and within it, the userSkeletons dictionary was defined. This dictionary held the totalSkeletons and skeletonCount values, allowing JavaScript functions to access and modify the user's skeleton count variables without constantly fetching SQL routes, which would slow down the program, and without accessing text on the DOM. This variable allowed for another benefit. Before the implementation of userSkeletons, many JavaScript functions were asyncronously modifying the totalSkeletons and skeletonCount text boxes on the DOM at the same time. This was leading to complications where functions would overwrite each other's work, and it also pointlessly increased the complication of the web app. To resolve this, I moved all updating of the tags whose ids were total-skeletons and skeleton-count to the resyncDOM.js function. This function fetches the values in totalSkeletons every 25 milliseconds, runs them through the formatNumberSuffix() function, and assigns the output to the text content of the total-skeletons and skeleton-count tags on the DOM. The reason I chose to do this refresh every 25 milliseconds is because another script, called perSecondOperations.js modifies the values in totalSkeletons every 25 milliseconds. The file perSecondOperations.js contains a function that adds the amount of skeletons the user's autodiggers have dug up in the last 25 milliseconds to the user's total skeletons and skeleton count.
