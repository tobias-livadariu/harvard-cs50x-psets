# CALCIUM CLICKER
#### Video Demo:  <URL HERE> ::TODO
#### Description:
Calcium Clicker is an incremental web application inspired by other famous incremental web apps like "Cookie Clicker," "Swarm Simulator," and "Antimatter Dimensions." In Calcium Clicker, users play as a necromancer to build their army of undead skeletons as large as possible. Users can get skeletons in two ways. The user can click the "Dig Up More" button to dig up skeletons manually, or they can purchase autodiggers to dig up skeletons for them automatically. Each autodigger digs up one skeleton per second, with multiple autodiggers stacking to produce very fast gains once the user buys a large number of them. The user can increase the number of skeletons they get per click by upgrading their shovel to higher tiers, with higher tiers generating exponentially more skeletons per click and costing exponentially more skeletons to buy. The web app displays two major text boxes at the top of the DOM to the user. The first has an id of "skeleton-count," which shows the skeletons the user currently owns and can spend on upgrades. The second has an id of "total-skeletons," which displays the total skeleton count that the user has generated, spent or not, over their account's entire lifetime. It is very important to note that certain functionalities of this program were taken from week 9's Finance pset. The login and logout routes, the @login_required route decorator, and parts of the configuration done to app.py to ensure it can handle user account data were taken from Finance's distribution code. Additionally, the register route was taken from my work in Finance, and the structure of Calcium Clicker's sqlite3 database was inspired by the database structure in Finance. It is also important to note that ChatGPT helped teach me how to use certain tools and syntax that I needed to complete this project. For example, it taught me how to use AJAX to asynchronously update data in the page's DOM without constantly reloading the page. It also taught me how to use fetch() and .then() in JavaScript to extract data from my flask routes and create anonymous functions that use the extracted data to do work. ChatGPT also helped me optimize my flask routes to be maximally efficient and to contain as few sqlite3 queries as possible. However, it is important to note that I did not copy any code from ChatGPT in this assignment. Rather, I used its suggestions to improve and build on my own ideas.

The user gains the ability to buy autodiggers and to upgrade their shovel when their total skeleton count reaches 10. Reaching a total skeleton count of 10 will trigger the page to refresh through the refreshPage() JavaScript function, generating more elements on the screen. When buying autodiggers, the user can choose between buying one, buying ten, or buying the maximum amount they can currently afford. The ability to buy multiple autodiggers at once was implemented through JavaScript and two flask routes, one that gets the number of autodiggers the user can afford and another that purchases the autodiggers. If the user buys a single autodigger, only the route that purchases autodiggers will run. After fetching the user's current skeleton count and the next autodigger's cost from the web app's SQL database, this route will make the transaction, and the database values will be updated. If the user decides to buy multiple autodiggers, first, the route that determines how many autodiggers the user can afford is run, which then passes values to the route that buys autodiggers, causing it to run slightly differently and buy multiple autodiggers depending on the values that the first route passed to it. The DOM is updated through asynchronous JavaScript to display the next autodigger count in either scenario. When upgrading their shovel, the user clicks a button on the screen that calls the buyShovel() JavaScript function. This function will fetch the "/buyShovel" route, which will SELECT values from the SQL database, check if the user can afford a shovel upgrade, and complete the transaction if the user has enough skeletons. It will then return, as JSON, the user's updated current shovel level and the maximum shovel level, a list of all shovel names based on their level, the cost of buying the next shovel, and the current skeleton count. The buyShovel() function will then fetch the "/updateStats" route, which will update the row in the SQL database's stats table containing the user's specific user_id with the new skeletonsPerClick value. This value is then returned to the buyShovel() function as JSON through fetch, which uses it, in conjunction with the values returned by the "/buyShovel" route, to asynchronously update the DOM with the user's new shovel and skeletonsPerClick.

Since Calicum Clicker is an incremental game, numbers on the DOM quickly grow. This could become problematic as text gets longer and longer, eventually reaching the boundries of its container and wrapping, which would ruin the style of the web app. To counteract this, I have implemented a jinja2 filter and a JavaScript function, both called formatNumberSuffix. This function takes in a integer as input, and finds the biggest triple power of ten (eg, one thousand, one million, etc.) which is less than the integer input. It will then divide that integer by the power of ten,  round the result to 2 decimal places, and add a special suffix depending on the integer's size. For example, if the number 1023 was run through formatNumberSuffix(), it would output 1.02k. This greatly improves the readability and aesthetic of the web app, but it was tricky to implement. At first, some of Calcium Clicker's JavaScript functions extracted numeric values for skeleton count directly from the DOM. This was problematic because if the text on the DOM was concatonated and given non-numeric characters, precise values could no longer be extracted from it. To fix this issue, the globalVariables.js file was made, and within it, the userSkeletons dictionary was defined. This dictionary held the totalSkeletons and skeletonCount values, allowing JavaScript functions to access and modify the user's skeleton count variables without constantly fetching SQL routes, which would slow down the program, and without accessing text on the DOM. This variable allowed for another benefit. Before the implementation of userSkeletons, many JavaScript functions were asyncronously modifying the totalSkeletons and skeletonCount text boxes on the DOM at the same time. This was leading to complications where functions would overwrite each other's work, and it also pointlessly increased the complication of the web app. To resolve this, I moved all updating of the tags whose ids were total-skeletons and skeleton-count to the resyncDOM.js function. This function fetches the values in totalSkeletons every 25 milliseconds, runs them through the formatNumberSuffix() function, and assigns the output to the text content of the total-skeletons and skeleton-count tags on the DOM. The reason I chose to do this refresh every 25 milliseconds is because another script, called perSecondOperations.js modifies the values in totalSkeletons every 25 milliseconds. The file perSecondOperations.js contains a function that adds the amount of skeletons the user's autodiggers have dug up in the last 25 milliseconds to the user's total skeletons and skeleton count. In reality, the gains generated by the autodiggers are only saved to the user's skeletonCount and totalSkeletons columns in the database every second to minimize the number of sqlite3 prompts, but this smooth accumulation of skeletons on the screen makes the web app look more responsive, and is why the DOM is resynced every 25 milliseconds.

I hope this README helped to clarify the purpose and functionality of my project! If you feel confused about any part of my final project, please look through my code. It is full of comments that explain the logic behind every single flask route and JavaScript function. Thank you for your time!
